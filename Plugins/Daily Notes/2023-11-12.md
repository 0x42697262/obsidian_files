---
classoption:
- table
header-includes: |
  \usepackage{wasysym}
  \usepackage{tcolorbox}
  \usepackage{amsthm,amssymb}
  \renewcommand{\qedsymbol}{\textbf{h.n.}}
  \newtcolorbox{mycode}{colback=black!5!white, colframe=white}
  \fboxsep1pt
  \renewenvironment{Shaded}{\begin{mycode}}{\end{mycode}}
  \let\OldTexttt\texttt
  \renewcommand{\texttt}[1]{\OldTexttt{\colorbox{black!5}{#1}}}
  \usepackage{xcolor}
  \let\oldlongtable\longtable
  \let\endoldlongtable\endlongtable
  \renewenvironment{longtable}{
  \rowcolors{2}{}{gray!5}  % row color
  \oldlongtable} {
  \endoldlongtable
  \global\rownum=0\relax}
  \usepackage{fvextra}
  \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}
  \widowpenalty10000
  \clubpenalty10000
---

# Counting Instructions with nested loops

## Binary Search

Try this binary search and compute for its T(n).

```{.cpp .numberLines}
bool search(int A[], int n, int x){
    int lb = 0, ub = n-1;

    while(lb <= ub){
        int mid = (lb + ub)/2;
    
		if(A[mid] == x)
			return true;
		else
		if(x < A[mid])
			ub = mid - 1;
		else
			lb = mid + 1;
  	}
  	return false;
}
```

Looking carefully at `search`, the iterators seem absent. There is no iterator that begins at some initial value and iterates until it reaches some bound. But we do have a lower bound in `lb` and an upper bound in `ub`. And looking at these bounds, they get updated based on `mid`. Here, `mid` is always half of the search area. Initially, the search area is the entire array, i.e. `lb = 0` and `ub = n-1` where `n` is the size of the array `A`. Taking into consideration the worst-case scenario where the item `x` is not in `A`, the search area initially will contain `n` items. For each iteration, the search area gets halved. In the last iteration the search area gets reduced to $1$ element or item, where `lb` and `ub` are the same value. Shown below is the repeated halving of `n`.

$$
\begin{aligned}
\frac{n}{1}, \frac{n}{2}, \frac{n}{4}, \frac{n}{8}, \ &..., \ 1 \\
\ \\
\frac{n}{2^0}, \frac{n}{2^1},\frac{n}{2^2}, \frac{n}{2^3}, \  &...,\ \frac{n}{2^i}
\end{aligned}
$$

It should be easy to see we need to find $i$ where $\frac{n}{2^i} = 1$. This signifies how many iterations need to be executed until the last iteration of the loop above in line $4$ where `lb` is equal to `ub`, i.e. when we are left with $1$ element or item.

Continuing the simplification, we have:

\begin{proof}
$$
\begin{aligned}
\frac{n}{2^i}&= 1 \\
2^i &= n \\
\log_{2}{2^i}&=\log_{2}{n}\\
i&=\log_{2}{n}
\end{aligned}
$$
\end{proof}

This means that that the upper bound for the number of iterations for the `search`  is $\log_{2}{n}$ and the lower bound is $0$.

Computing for $T(n)$ we have:

$$
\begin{aligned}
T(n) &= \overbrace{\sum_{i=0}^{\log_{2}{n}} \underbrace{8}_{\texttt{lb<=ub, mid = (lb+ub)/2, A[mid]==x, x < A[mid], ub=mid-1}}}^{\text{entire while loop}} + \overbrace{5}^{\texttt{lb=0, ub=n-1, lb<=ub, return false}}\\
&= \sum_{i=0}^{\log_{2}{n}} 8 + 5\\
&= 8 \cdot (\log_{2}{n} + 1) + 5\\
&= 8\log_{2}{n} + 13\\
\end{aligned}
$$

Notice that in choosing which bound to update based on whether `x < A[mid]`, without loss of generality we can simply choose either `ub = mid - 1` or `lb = mid + 1`, since they have the same count anyway. The above computation chose `ub = mid - 1`.

## Basic Sorting

Binary search in the previous section was only ppossible because the elements were of the given array were sorted. But what if the elements are not? How can we do sorting?

One of the simplest sorting algorithm is $\text{selection sort}$. The algorithm works by partitioning or dividing the array into $2$ areas, the unsorted portion and the sorted portion. Initially, the entire array is the unsorted portion. Consider the following array with size $10$ with indices going from $0$ to $9$:

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 603 | 397 | 986 | 529 | 325 | 438 | 724 | 893 | 244 | 665 |

We repeatingly swap the smallest item and the first element of the unsorted area of the array. In the case above, the unsorted area goes from index $0$ to index $9$. The smallest item among all those elements is $244$ found in index $8$. 

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| **603** | 397 | 986 | 529 | 325 | 438 | 724 | 893 | **244** | 665 |

So we swap this with the first element of the unsorted area found in index $0$ which is $603$.

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| ***244*** | 397 | 986 | 529 | 325 | 438 | 724 | 893 | **603** | 665 |

Doing so places the smallest item in its correct location in terms of sorted ordering. Hence, it becomes the lone element in the sorted area of the array. And the unsorted area now goes from index $1$ to index $9$.

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| ***244*** | 397 | 986 | 529 | 325 | 438 | 724 | 893 | 603 | 665 |

We repeat the same process of swapping the smallest item and first element of the unsroted area of the area. We find $325$ to be the smallest. And so we swap this with $397$. 

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| ***244*** | **325** | 986 | 529 | **397** | 438 | 724 | 893 | 603 | 665 |

Doing so moves the lower bound index of the unsorted area one position to the right.

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| ***244*** | ***325*** | 986 | 529 | 397 | 438 | 724 | 893 | 603 | 665 |

The process ends when the unsorted area has one element or item left. The table below shows the rest of $selection \ sort$.


| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | start | min | min_idx |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| ***244*** | ***325*** | 986 | 529 | 397 | 438 | 724 | 893 | 603 | 665 | 2 | 
| ***244*** | ***325*** | **986** | 529 | **397** | 438 | 724 | 893 | 603 | 665 | 2 | 397 | 4 |
| ***244*** | ***325*** | **397** | 529 | **986** | 438 | 724 | 893 | 603 | 665 | 2 | 397 | 4 |
| ***244*** | ***325*** | ***397*** | 529 | 986 | 438 | 724 | 893 | 603 | 665 | 3 |  |  |
| ***244*** | ***325*** | ***397*** | **529** | 986 | **438** | 724 | 893 | 603 | 665 | 3 | 438 | 5 |
| ***244*** | ***325*** | ***397*** | **438** | 986 | **529** | 724 | 893 | 603 | 665 | 3 | 438 | 5 |
| ***244*** | ***325*** | ***397*** | ***438*** | 986 | 529 | 724 | 893 | 603 | 665 | 4 |  |  |
| ***244*** | ***325*** | ***397*** | ***438*** | **986** | **529** | 724 | 893 | 603 | 665 | 4 | 529 | 5 |
| ***244*** | ***325*** | ***397*** | ***438*** | **529** | **986** | 724 | 893 | 603 | 665 | 4 | 529 | 5 |
| ***244*** | ***325*** | ***397*** | ***438*** | ***529*** | 986 | 724 | 893 | 603 | 665 | 5 |  |  |
| ***244*** | ***325*** | ***397*** | ***438*** | ***529*** | **986** | 724 | 893 | **603** | 665 | 5 | 603 | 8 |
| ***244*** | ***325*** | ***397*** | ***438*** | ***529*** | **603** | 724 | 893 | **986** | 665 | 5 | 603 | 8 |
| ***244*** | ***325*** | ***397*** | ***438*** | ***529*** | ***603*** | 724 | 893 | 986 | 665 | 6 | |  |
| ***244*** | ***325*** | ***397*** | ***438*** | ***529*** | ***603*** | **724** | 893 | 986 | **665** | 6 | 665 | 9 |
| ***244*** | ***325*** | ***397*** | ***438*** | ***529*** | ***603*** | **665** | 893 | 986 | **724** | 6 | 665 | 9 |
| ***244*** | ***325*** | ***397*** | ***438*** | ***529*** | ***603*** | ***665*** | 893 | 986 | 724 | 7 | |  | 
| ***244*** | ***325*** | ***397*** | ***438*** | ***529*** | ***603*** | ***665*** | **893** | 986 | **724** | 7 | 724 | 9 |
| ***244*** | ***325*** | ***397*** | ***438*** | ***529*** | ***603*** | ***665*** | **724** | 986 | **893** | 7 | 724 | 9 |
| ***244*** | ***325*** | ***397*** | ***438*** | ***529*** | ***603*** | ***665*** | ***724*** | 986 | 893 | 8 |  |  |
| ***244*** | ***325*** | ***397*** | ***438*** | ***529*** | ***603*** | ***665*** | ***724*** | **986** | **893** | 8 |893 | 9 |
| ***244*** | ***325*** | ***397*** | ***438*** | ***529*** | ***603*** | ***665*** | ***724*** | **893** | **986** | 8 | 893 | 9 |
| ***244*** | ***325*** | ***397*** | ***438*** | ***529*** | ***603*** | ***665*** | ***724*** | ***893*** | 986 | 9 |  |  |

The iteration stops when the start index and end index both refer to the last element or item of the array.

Let's define the $selection\ sort$.

`void selectionSort(int*, int)`

The first argument is the array, and the second signifies the size of the array.

Based on the discussion above, our search area initially starts at index $0$ all the way to the index `n - 2` (this is the last iteration where the unsorted area has been reduced to $2$ elements). The index iterator moves $1$ position to the right at each iteration, adjusting the the unsored area.

``` {.cpp .numberLines}
void selectionSort(int *A, int n){
	for(int i=0; i<n-1; i++){

	}
}
```

The loop above updates the search area. For each iteration, we look for the smallest item and swap this with the first element in the search area.

```{.cpp .numberLines}
void selectionSort(int *A, int n){
	for(int i=0; i<n-1; i++){
		int min = i;
		for(int j=i+1; j<n; j++){
			if(A[j] < A[min])	
				min = j;
		}
	}
}
```

We assume that the first element in the search area is the minimum. We store the index instead of the actual minimum. This is because we would need to swap elements, and we will need to know where they are stored in the array.

```{.cpp .numberLines}
void selectionSort(int *A, int n){
	for(int i=0; i<n-1; i++){
		int min = i;
		for(int j=i+1; j<n; j++){
			if(A[j] < A[min])	
				min = j;
		}
		int tmp = A[i];
		A[i] = A[min];
		A[min] = tmp;
	}
}
```
How do we compute for the $T(n)$ of the `selectionSearch`? Notice that we have $2$ nested loops. How are instructions counted when presented with nested loops? Let's begin with simpler ones. Check out the next section.

## Nested loop with constant upper bounds

When the solution to a problem involves a nested loop, we count from the innermost loop going outward.

Let's have a simple example. Say we have a binary image (meaning black (1) or white pixels (0) only) represented by 10x10 array. And we simply count how many foreground pixels there are (pixels that are 1)

```{.cpp .numberLines}
int countForegroundPixels(int img[10][10]){
    int count = 0;
    for(int i=0; i<10; i++)
        for(int j=0; j<10; j++)
            if(img[i][j] == 1)
                count++;
}
```

With nested loops, we count from the innermost loop, going outward. And since we are counting for the worst-case scenario, we assume that the image is composed of foreground pixels only, and therefore the selection condition that checks if the pixel is $1$ always evaluates to true and `count++` gets executed everytime. So there are $4$ expressions that get repeated many times and these are the following:

 * `j < 10`
 * `img[i][j] == 1`
 * `count++`
 * `j++`

with $1$ count for the initialization of $j$, and another for the check when $j$ is equal to $10$.
For the inner loop, we have the following:

$$
\begin{aligned}
\sum_{j=0}^{9} 4 + 2 &= 4 \cdot (9 - 0 + 1) + 2\\
&= 4 \cdot (10) + 2\\
&= 42\\
\end{aligned}
$$

Now, let's look at the outer loop. Notice that the inner loop is repeated as many times as the condition of the outer loop and the `i++`. The following are the expressions repeated many times over:

 * `i < 10`
 * the entire inner loop
 * `i++`

with $1$ count for the initialization of $count$, $1$ count for the initialization of $i$, and another for the check when $i$ is equal to $10$.

The T(n) of `countForegroundPixels` is as follows:

$$
\begin{aligned}
T(n) &= \sum_{i=0}^{9} (2 + 42) + 3 \\
&= 44 \cdot (9 - 0 + 1) + 3\\
&= 44 \cdot (10) + 3\\
&= 443\\
\end{aligned}
$$

Recall that $\sum_{i=0}^{9} c$, where c is a constant, is the same as $\sum_{i=1}^{10} c$. We can, then, compute for the T(n) of $countForegroundPixels$ as follows:

$$
\begin{aligned}
T(n) &= \overbrace{\sum_{i=1}^{10} \biggl(\underbrace{2}_{\texttt{i<10,i++}} + \Bigl(\underbrace{\sum_{j=1}^{10} \overbrace{4}^{\texttt{j<10, img[i][j]==1, count++, j++}} + \underbrace{2}_{\texttt{j=0, j<10 (false)}}}_{\text{inner loop}} \Bigr) \biggr)}^{\text{entire outer loop}} + \underbrace{3}_{\texttt{count=0, i=0, i<10 (false)}}\\
&= \sum_{i=1}^{10} \biggl(2 + \Bigl(\sum_{j=1}^{10} 4 + 2 \Bigr) \biggr) + 3\\
&= \sum_{i=1}^{10} (2 + 4 \cdot 10 + 2 ) + 3\\
&= \sum_{i=1}^{10} 44 + 3\\
&= 44 \cdot 10 + 3\\
&= 443\\
\end{aligned}
$$

## Nested loop with both upper bounds equal to some `n`

If the input image is `n x n`, we have the following:

```{.cpp .numberLines}
int countForegroundPixels(int img[][1000], int n){
  	int count = 0;
  	for(int i=0; i<n; i++)
    	for(int j=0; j<n; j++)
      		if(img[i][j] == 1)
        		count++;
}
```

$$
\begin{aligned}
T(n) &= \overbrace{\sum_{i=1}^{n} \biggl(\underbrace{2}_{\texttt{i<n, i++}} + \Bigl(\underbrace{\sum_{j=1}^{n} \overbrace{4}^{\texttt{j<n, img[i][j]==1, count++, j++}} + \underbrace{2}_{\texttt{j=0, j<n (false)}}}_{\text{inner loop}} \Bigr) \biggr)}^{\text{entire outer loop}} + \underbrace{3}_{\texttt {count=0, i=0, i<n (false)}}\\
&= \sum_{i=1}^{n} \biggl(2 + \Bigl(\sum_{j=1}^{n} 4 + 2 \Bigr) \biggr) + 3\\
&= \sum_{i=1}^{n} (2 + 4n + 2 ) + 3\\
&= \sum_{i=1}^{n} (4n + 4) + 3\\
&= n \cdot (4n + 4) + 3\\
&= 4n^{2} + 4n + 3\\
\end{aligned}
$$

### Matrix Addition

Assume that we have $2\ n \times n$ matrices and we want add them and store the result into a third $n \times n$ matrix. This should involve a simple addition of the elements row by row.

```{.cpp .numberLines}
//the arrays are nxn but max capacity is 1000x1000
//here, n<=1000
void add(int A[1000][1000], int B[1000][1000], int C[1000][1000], int n){
	for(int r=0; r<n; r++){
		for(int c=0; c<n; c++)
			C[r][c] = A[r][c] + B[r][c];
	}
}
```

Since the solution is fairly straight forward, let's work with this from the inner loop going outward. We will adjust the bounds here from $0$ to $n-1$ to $1 to n$.

$$
\begin{aligned}
inner\ loop &= \sum_{c=1}^{n}\overbrace{4}^{\texttt{c<n, C[r][c] = A[r][c] + B[r][c], c++}} + \underbrace{2}_{\texttt{c=0, c<n(false)}} \\
&= \sum_{c=1}^{n}4 + 2\\
&= 4n + 2\\
\end{aligned}
$$

This entire inner loop is iterated as many times as the outer loop. Full computation is shown below.

$$
\begin{aligned}
T(n) &= \sum_{r=1}^{n}\Bigl(\overbrace{2}^{\texttt{r<n, r++}} + \underbrace{\sum_{c=1}^{n}4 + 2}_{{\texttt{inner for loop}}} \Bigr) + \underbrace{2}_{\texttt{r=0, r<n(false)}} \\
&= \sum_{r=1}^{n}\Bigl(2 + \sum_{c=1}^{n}4 + 2\ \Bigr) + 2\\
&= \sum_{r=1}^{n}\Bigl(2 + 4n + 2\ \Bigr) + 2\\
&= \sum_{r=1}^{n}\Bigl(4n + 4\ \Bigr) + 2\\
&= \sum_{c=1}^{n}4n + \sum_{c=1}^{n}4 + 2\\
&= 4n^2 + 4n + 2
\end{aligned}
$$

## Nested loop with differing variable upper bounds

And if the image is `n x m`, we have the following:

```{.cpp .numberLines}
int countForegroundPixels(int img[][1000], int n, int m){
  	int count = 0;
  	for(int i=0; i<n; i++)
    	for(int j=0; j<m; j++)
      		if(img[i][j] == 1)
        		count++;
}
```

$$
\begin{aligned}
T(n) &= \overbrace{\sum_{i=1}^{n} \biggl(\underbrace{2}_{\texttt{i<n, i++}} + \Bigl(\underbrace{\sum_{j=1}^{m} \overbrace{4}^{\texttt{j<m, img[i][j]==1, count++, j++}} + \underbrace{2}_{\texttt{j=0,j<m (false)}}}_{\text{inner loop}} \Bigr) \biggr)}^{\text{entire outer loop}} + \underbrace{3}_{\texttt{count=0, i=0, i<n (false)}}\\
&= \sum_{i=1}^{n} \biggl(2 + \Bigl(\sum_{j=1}^{m} 4 + 2 \Bigr) \biggr) + 3\\
&= \sum_{i=1}^{n} (2 + 4m + 2 ) + 3\\
&= \sum_{i=1}^{n} (4m + 4) + 3\\
&= n \cdot (4m + 4) + 3\\
&= 4nm + 4n + 3\\
\end{aligned}
$$

Let's say we are given an `m x n` matrix and we want to know if there's at least one row with identical items. We would need to check each row of the matrix since there's a possibility that not one row has identical items.

The loop shown next uses `i` to navigate through the rows.

```{.cpp .numberLines}
//n rows with m columns
bool hasRowIdenticalItems(int matrix[][1000], int n, int m){ 
  	for(int i=0; i<n; i++){

	}
}
```

The inner loop shown next uses `j` to navigate through the columns.
 
```{.cpp .numberLines}
//n rows with m columns
bool hasRowIdenticalItems(int matrix[][1000], int n, int m){ 
  	for(int i=0; i<n; i++){
		for(int j=0; j<m-1; j++){

		}
	}
}
```
The inner loop checks if the items in the columns are identical. This requires checking adjacent elements in the row, hence, `j` goes until `m - 2` only. We need not check if adjacent items are identical since we will need to go and check the $2$ adjacent elements, if this is the case. Instead, we will check if they not equal and outrightly break from the inner loop and go to the next row. When `j` reaches `m - 1`, the inner loop terminates and this means that all the elements in the $ith$ row are identical.
 
```{.cpp .numberLines}
//matrix has n rows and m columns
bool hasRowIdenticalItems(int matrix[][1000], int n, int m){
  	for(int i=0; i<n; i++){
		for(int j=0; j<m-1; j++){
			if(matrix[i][j] != matrix[i][j+1])
				break;
		}
		if(j==m-1)
			return true;
	}
	return false;
}
```
We may also introduce a flag to check if there is such a row. This is shown the following solution.
```{.cpp .numberLines}
//matrix has n rows and m columns
bool hasRowIdenticalItems(int matrix[][1000], int n, int m){
  	for(int i=0; i<n; i++){
		bool same = true;
		for(int j=0; j<m-1; j++){
			if(matrix[i][j] != matrix[i][j+1]){
				same = false;
				break;
			}
		}
		if(same==true)
			return true;
	}
	return false;
}
```
The worst-case scenario for this problem is when all the elements are identical except for the last item in each row. 
Except for the last row, which has all elements identical. 
Below is a sample matrix that exhibits the worst-case scenario.

$$
\begin{bmatrix} 
1 & 1 & 1 & 1 & 2\\
2 & 2 & 2 & 2 & 3\\
5 & 5 & 5 & 5 & 9\\
7 & 7 & 7 & 7 & 8\\
3 & 3 & 3 & 3 & 6\\
4 & 4 & 4 & 4 & 0\\
8 & 8 & 8 & 8 & 8\\
\end{bmatrix}
$$

This will be the basis for the computation of the $\ T(n)$. This is interesting. Carefully analyzing the inner loop, the check on the last row, comparing `matrix[i][j] != matrix[i][j+1]` on the last two elements, will fail and will not set `same` to `false`. 

The strategy here is to isolate the case for the last row. And for each of the upper rows, the check on the last two elements will pass, setting `same` to `false`, and breaking from the loop.

Let's do this step-by-step, beginning with the inner loop. Notice that in comparing the last $2$ elements in the row (`matrix[i][m-2]` and `matrix[i][m-1]`), the loop breaks and so `j++` does not get executed in the last iteration of the inner loop.

```{.cpp .numberLines}
for(int j=0; j<m-1; j++){
	if(matrix[i][j] != matrix[i][j+1]){
		same = false;
		break;
	}
}
```

$$
\begin{aligned}
inner \ loop\ without\ the\ last\ iteration &= \sum_{j=1}^{m-2} \underbrace{5}_{\texttt{j<m-1, matrix[i][j]!=matrix[i][j+1], j++}} \\ \\
&= 5 \cdot (m - 2)\\ \\
&= 5m - 10
\end{aligned}
$$

We now compute the last iteration where the inner loop breaks. This happens just once. And this is when we compare the last $2$ items.

$$
\begin{aligned}
inner \ loop's \ last \ iteration &=\sum_{j=m-1}^{m-1} \underbrace{6}_{\texttt{j<m-1, matrix[i][j]!=matrix[i][j+1], same = false, break}} \\ \\
&= 6
\end{aligned}
$$

For our purpose, we consider the `break` to cost us $1$ unit of time. That should give us a total of $6$ units of time for that last iteration. It should be important to note that for counting purposes, we have set our `j` to start at $1$, instead of $0$. This is not to be confused with the condition check `j < m-1`.

Plus we count the initialization `j = 0`. This means that we do not count the usual final check on the condition of the loop `j < m-1` for when it evaluates to false because the loop will terminate due to the `break`. And hence, the `j++` is not accounted for as well.

The total count for inner loop then is:

$$
\begin{aligned}
&= 5m - 10 + 6 + 1 \\
&= 5m - 3
\end{aligned}
$$

The computed inner loop above will be iterated only for the first $n - 1$ rows of the matrix. Again, this is because the last row will have identical items (worst-case scenario). 


Partial $T(n)$ is given below (note that we adjust the start value of $i$ for counting purposes):


$$
\begin{aligned}
Partial\ T(n) &= \sum_{i=1}^{n-1} \biggl(\underbrace{4}_{\texttt{i<n, same=true, same==true, i++}} + \Bigl(\overbrace{\sum_{j=1}^{m-2}{5} + 6 + 1}^{\texttt{total inner loop}} \Bigr) \biggr)\\ \\
&= \sum_{i=1}^{n-1} \biggl(4 + \Bigl(5\cdot(m-2)+7 \Bigr) \biggr)\\ \\
&= \sum_{i=1}^{n-1} \biggl( 4+ (5m - 3) \biggr)\\ \\
&= \sum_{i=1}^{n-1} \biggl( 5m +1 \biggr)\\ \\
&= (n-1) \cdot (5m+1)\\ \\
&= 5nm-5m + n\\
\end{aligned}
$$

The final iteration of the outer loop will check the last row and this last row should contain identical items. Again, this is the worst-case scenario.

Similarly, let's begin with the inner loop. Recall that the inner loop will not execute `same = false` and the `break` since `matrix[i][j]` is equal to `matrix[i][j+1]`.

```{.cpp .numberLines}
for(int j=0; j<m-1; j++){
	if(matrix[i][j] != matrix[i][j+1]){
		same = false;
		break;
	}
}
```
$$
\begin{aligned}
inner\ loop &= \sum_{j=1}^{m-1} \underbrace{5}_{\texttt{j<m-1, matrix[i][j]!=matrix[i][j+1], j++}} + \overbrace{2}^{\texttt{last check on j<m-1 (false)}} + \underbrace{1}_{\texttt{j=0}} \\ \\
&= \sum_{j=1}^{m-1}5 + 2 + 1 \\ \\
&= \sum_{j=1}^{m-1}5 + 3 \\ \\
&= 5 \cdot (m - 1)\\ \\
&= 5m - 5 + 3 \\ \\
&= 5m - 2 
\end{aligned}
$$


```{.cpp .numberLines}
//matrix has n rows and m columns
bool hasRowIdenticalItems(int matrix[][1000], int n, int m){
  	for(int i=0; i<n; i++){
		bool same = true;
		for(int j=0; j<m-1; j++){
			if(matrix[i][j] != matrix[i][j+1]){
				same = false;
				break;
			}
		}
		if(same==true)
			return true;
	}
	return false;
}
```
Let's now work with the last iteration of the outer loop shown above. Since this is looking at the last row with identical items, `same` is never set to `false`, hence the check `same==true` will evaluate to `true` and will execute `return true`. This means that the last `i++` and the last check on `i<n` will not get to see the light, err, will not be executed.

$$
\begin{aligned}
Last\ iteration\ of\ outer\ loop &= \sum_{i=n}^{n} \biggl(\underbrace{4}_{\texttt{i<n, same=true, same==true, return true}} + \Bigl(\sum_{j=1}^{m-1} 5 + 2 + 1 \Bigr) \biggr)\\ \\
&= \sum_{i=n}^{n} \biggl(4 + \Bigl(\sum_{j=1}^{m-1} 5 + 3 \Bigr) \biggr)\\ \\
&= \sum_{i=n}^{n} \Bigl(4 + 5\cdot(m - 1)+3\Bigr)\\ \\
&= \sum_{i=n}^{n} \Bigl(4 + 5m - 5 +3\Bigr)\\ \\
&= \sum_{i=n}^{n} \Bigl(4 + 5m - 2\Bigr)\\ \\
&= \sum_{i=n}^{n} \Bigl(5m + 2\Bigr)\\ \\
&= 5m + 2\\
\end{aligned}
$$

Putting all computations together, we have:

$$
\begin{aligned}
T(n) &= \overbrace{\sum_{i=1}^{n-1} \biggl(4 + \Bigl(\sum_{j=1}^{m-2}{5} + 6 + 1\Bigr) \biggr)}^{\texttt{first n-1 iterations}} + \underbrace{\sum_{i=n}^{n} \biggl(4 + \Bigl(\sum_{j=1}^{m-1} 5 + 2 + 1 \Bigr) \biggr)}_{\texttt{last iteration}}\\
\\
&= \sum_{i=1}^{n-1} \biggl(4 + \Bigl(\sum_{j=1}^{m-2}{5} + 7 \Bigr) \biggr)+ \sum_{i=n}^{n} \biggl(4 + \Bigl(\sum_{j=1}^{m-1} 5 + 3 \Bigr) \biggr)\\
\\
&= \sum_{i=1}^{n-1} \biggl(4 + \Bigl(5\cdot(m-2)+7 \Bigr) \biggr)+\sum_{i=n}^{n} \Bigl(4 + 5\cdot(m - 1)+3\Bigr)\\
\\
&= \sum_{i=1}^{n-1} \biggl( 4+ 5m - 10 + 7 \biggr)+\sum_{i=n}^{n} \Bigl(4 + 5m - 5 +3\Bigr)\\
\\
&= \sum_{i=1}^{n-1} \biggl( 5m +1 \biggr) + \sum_{i=n}^{n} \Bigl(5m + 2\Bigr)\\
\\
&= (n-1) \cdot (5m+1) + (5m+2)\\
\\
&= 5nm-5m + n + 5m + 2\\
\\
&= 5nm + n + 2\\
\end{aligned}
$$

## Back to Selection Sort

We are now ready to compute the $T(n)$ of `selectionSort`.

```{.cpp .numberLines}
void selectionSort(int *A, int n){
	for(int i=0; i<n-1; i++){
		int min = i;
		for(int j=i+1; j<n; j++){
			if(A[j] < A[min])	
				min = j;
		}
		int tmp = A[i];
		A[i] = A[min];
		A[min] = tmp;
	}
}
```

As per usual, we begin with the inner loop and adjusted the bounds here to start from $1$ instead of $0$. Outer loop, for counting purposes, now goes from $1$ to $n-1$. Inner loop goes from $i+1$ to $n$.

$$
\begin{aligned}
inner\ for\ loop &= \sum_{j=i+1}^{n}\overbrace{4}^{\texttt{j<n, A[j]<A[min], min=j, j++}} + \underbrace{3}_{\texttt{j=i+1, j<n(false)}} \\
&= \sum_{j=i+1}^{n}4 + 3\\
&= 4\cdot\underbrace{(n - (i+1) + 1)}_{\texttt{upperbound - lowerbound + 1}} + 3\\
&= 4\cdot(n - i - 1 + 1) + 3\\
&= 4\cdot(n - i) + 3\\
&= 4n - 4i + 3\\
\end{aligned}
$$

This entire inner loop is iterated as many times as the other statements in the outer loop. Full computation is shown below.

$$
\begin{aligned}
T(n) &= \sum_{i=1}^{n-1}\Bigl(\overbrace{7}^{\texttt{i<n-1, min=i, tmp=A[i], A[i]=A[min], A[min]=tmp, i++}} + \underbrace{\sum_{j=i+1}^{n}4 + 3}_{{\texttt{inner for loop}}} \Bigr) + \underbrace{3}_{\texttt{i=0, i<n-1(false)}} \\
&= \sum_{i=1}^{n-1}\Bigl(7 + \sum_{j=i+1}^{n}4 + 3\Bigr) + 2\\
&= \sum_{i=1}^{n-1}\Bigl(7 + 4n - 4i + 3\Bigr) + 2\\
&= \sum_{i=1}^{n-1}\Bigl(4n - 4i + 10\Bigr) + 2\\
&= \sum_{i=1}^{n-1}4n + \sum_{i=1}^{n-1}4i + \sum_{i=1}^{n-1}10 + 2\\
&= 4n\cdot(n-1) + 4\cdot\biggl(\underbrace{\frac{(n-1)\cdot(n-1+1)}{2}}_{\sum_{i=1}^{n}\frac{n\cdot(n+1)}{2}\texttt{\ adjusted for upper bound n-1}}\biggr) + 10\cdot(n-1)+2\\\\
&= 4n^2 - 4n + \frac{4(n-1)(n)}{2} + 10n - 10 + 2\\
&= 4n^2 - 4n + 2(n^2-n) + 10n - 8\\
&= 4n^2 - 4n + 2n^2 -2n + 10n - 8\\
&= 6n^2 + 4n - 8\\
\end{aligned}
$$



## Nested loop with non-standard bounds (Primes less than `n`)

### Naive solution

This solution will simply check if the numbers from 2 to n-1 are prime or not. The outer loop should produce the candidate primes like so:

```{.cpp .numberLines}
for(int cp=2; cp<n; c++){

}
```

For each of the candidate primes, we verify if it is indeed prime. We will use the primality check that only goes up to the square root of the candidate prime. Let's introduce a flag that assumes that the candidate prime is indeed prime. Once a factor is found, we reverse this flag.

```{.cpp .numberLines}
void primesLessThanN(int n){
	for(int cp=2; cp<n; c++){
		bool prime = true;
		for(int cf = 2; cf*cf <= cp; cf++){
			if(cp%cf==0){
				prime = false;
				break;
			}
		}
		if(prime == true)
			cout<<cp<<" ";
	}
	cout<<endl;
}
```

The simplistic view of the worst-case scenario here is that every candidate prime is prime indeed. So let's work on this first beginning with the inner loop:
```{.cpp .numberLines}
for(int cf = 2; cf*cf <= cp; cf++){
	if(cp%cf==0){
		prime = false;
		break;
	}
}
```
$$
\begin{aligned}
inner\ loop &= \sum_{j=2}^{\overbrace{\sqrt{i}}^{\texttt{i here represents cp}}} \underbrace{5}_{\texttt{cf*cf<=cp, cp\%cf==0, cf++}} + \overbrace{2}^{\texttt{cf*cf<=cp (false)}} + \underbrace{1}_{\texttt{cf=2}}\\
&= \sum_{j=2}^{\sqrt{i}} 5 + 2+ 1\\
&= \sum_{j=2}^{\sqrt{i}} 5 + 3\\
&= 5\cdot(\sqrt{i}-2+1) + 3\\
&= 5\cdot(\sqrt{i}-1) + 3\\
&= 5\sqrt{i} - 5 + 3\\
&= 5\sqrt{i} - 2
\end{aligned}
$$

Incorporating this with the outer loop for the full $T(n)$, we have:

$$
\begin{aligned}
T(n) &= \sum_{i=2}^{n-1}\biggl(\overbrace{5}^{\texttt{cp<n,prime=true,prime==true,cout,cp++}}+\underbrace{\Bigl(\sum_{j=2}^{\sqrt{i}} 5 + 2 + 1 \Bigl)}_{\texttt{inner loop}}\biggr) + \overbrace{1}^{\texttt{cp<n (false)}} + \underbrace{1}_{\texttt{cp = 2}}\\
&= \sum_{i=2}^{n-1}\biggl(5+\underbrace{\Bigl(\sum_{j=2}^{\sqrt{i}} 5 + 2 + 1 \Bigl)}_{5\sqrt{i}-2}\biggr)+ 1 + 1\\
&= \sum_{i=2}^{n-1}\biggl(5+\Bigl(5\sqrt{i}-2\Bigl)\biggr)+ 2\\
&= \sum_{i=2}^{n-1}\biggl(5\sqrt{i}-3\biggr)+ 2\\
&= 5\cdot\sum_{i=2}^{n-1}\sqrt{i}-\sum_{i=2}^{n-1}3+ 2\\
\end{aligned}
$$

The $\ \sum_{i=1}^{n}\sqrt{i}\ $ is essentially $\sqrt{1} + \sqrt{2} + \sqrt{3} +\ \ldots +\sqrt{n}\ $. Its closed form is $\approx\ \frac{2}{3}n^{\frac{3}{2}}$. Let's use this form.

$$
\begin{aligned}
T(n) &= 5\cdot\sum_{i=2}^{n-1}\sqrt{i}-\sum_{i=2}^{n-1}3+ 2\\
&= 5\cdot(\frac{2}{3}n^{\frac{3}{2}}) - 3\cdot(n-1-2+1) + 2\\
&= \frac{10}{3}n^{\frac{3}{2}} - 3\cdot(n-2) + 2\\
&= \frac{10}{3}n^{\frac{3}{2}} - 3n-6+ 2\\
&= \frac{10}{3}n^{\frac{3}{2}} - 3n - 4\\
\end{aligned}
$$

Notice that we oversimplified the computation by using $\ \sum_{i=1}^{n}\sqrt{i}\ $ instead of using $\ \sum_{i=2}^{n-1}\sqrt{i}\ $. We can simplify this further by subtracting $\sqrt{n}\ $ and $\sqrt{1}\ $ from $\frac{2}{3}n^{\frac{3}{2}}$. This is left as an exercise for you.

Obviously, the computed time does not accurately describe the solution presented. The assumption we used here was that every candidate prime is indeed prime. But this is not case. We have to consider that the inner loop will only go all the way to the $\sqrt{cp}\ $ only if `cp` is indeed prime.

With this, we take a look at the inner loop once more:

```{.cpp .numberLines}
for(int cf = 2; cf*cf <= cp; cf++){
	if(cp%cf==0){
		prime = false;
		break;
	}
}
```

For every `cp` that is prime, the inner loop goes all the way to the $\sqrt{cp}$. From an earlier computation with the outer loop, we get $5\cdot\sum_{i=2}^{n-1}\sqrt{i}\ \ \forall\ i\ {\text{that is prime.}}$ This means the following:

$$
Let\ S_{1} = \sqrt{2} + \sqrt{3} + \sqrt{5} + \sqrt{7} + \sqrt{11} +\ \ldots +\sqrt{p}
$$

$p$ there is the largest prime less than $n$. Unfortunately, there is no known closed form approximation for this sum. And you guessed it, the prime numbers do not have a known pattern, for now. 

On top of $S_1$, we also have to account for all non-prime $cp$. This means all $cp$ that are divisible by $2, 3, 5, 7, 11, 13, ...$, i.e. all $cp$ that are divisible by prime numbers. We need to account for them because when $cp$ is non-prime, it will not take the inner loop to run as worse as the case when $cp$ is prime. This is obvious because the check `cp%cf==0` will evaluate to `true` and will prematurely break from the loop costing the solution lesser iterations for the inner loop when $cp$ is not prime.

Again, since the prime numbers do not have a known pattern, for now, a closed form bound cannot be had. But for all intents and purposes, the computed approximation of $\frac{10}{3}n^{\frac{3}{2}} - 3n - 4$ is the upper bound. It means that our first solution to generating all primes less than $n$, cannot be worse than the computed approximation, i.e. $T(n) \leq \frac{10}{3}n^{\frac{3}{2}} - 3n - 4$.

### Sieve of Eratosthenes

Based on the discussion above, it can be concluded that if a number is not prime, then some prime number must divide it or some prime number is a factor. Take $8$ for instance. It is divisible by $2$, which is a prime number. All even numbers are divisible by $2$. Take $15$, it is divisble by $3$, a prime number. $25$ is divisible by $5$, also a prime number.

This is the result of the Fundamental Theorem of Arithmetic which states that every positive integer greater than 1 can be uniquely expressed as a product of prime numbers, up to the order of the factors.

This means that there is really no need to check if a $cp$ is indeed prime. All we need to do is for every prime number we get, we can "cancel" all its multiples and tag them as not prime. This is the Sieve of Eratosthenes.

Let's say we want to find all the prime numbers less than 60. The following are the numbers with are interested in.

2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59

Initially, we assume that all these numbers are prime. Then for every prime number have, we cancel the primality of all its multiples.

Let's take a look at 2. We assumed this to be prime. And look at all its multiples less than 60.

$2$ 3 **4** 5 **6** 7 **8** 9 **10** 11 **12** 13 **14** 15 **16** 17 **18** 19 **20** 21 **22** 23 **24** 25 **26** 27 **28** 29 **30** 31 **32** 33 **34** 35 **36** 37 **38** 39 **40** 41 **42** 43 **44** 45 **46** 47 **48** 49 **50** 51 **52** 53 **54** 55 **56** 57 **58** 59

We cancel their primality and remove them from our set.

$2$ 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 57 59

We move on to the next prime, which, in this case is $3$. And take a look at all its multiples.

$2\ 3$ 5 7 **9** 11 13 **15** 17 19 **21** 23 25 **27** 29 31 **33** 35 37 **39** 41 43 **45** 47 49 **51** 53 55 57 59

We cancel their primality and remove them from our set.

$2\ 3$ 5 7 11 13 17 19 23 25 29 31 35 37 41 43 47 49 53 55 57 59

We repeat the same process, this time with $5$.

$2\ 3\ 5$ 7 11 13 17 19 23 **25** 29 31 **35** 37 41 43 47 49 53 **55** 57 59

We now have:

$2\ 3\ 5$ 7 11 13 17 19 23 29 31 37 41 43 47 49 53 57 59

And then with $7$ with 49 as its only factor remaining in our set.

$2\ 3\ 5\ 7$ 11 13 17 19 23 29 31 37 41 43 47 **49** 53 57 59

Removing it, we have:

$2\ 3\ 5\ 7$ 11 13 17 19 23 29 31 37 41 43 47 53 57 59

We can do this process all the way to the multiples of $59$. But notice that no other numbers get cancelled. This should give us a clue as to when we should this repetition.

Let's translate our solution to code. We need a way to represent and store the numbers from $1$ to $n-1$ (all primes less than $n$). This should obviously be an array.

We can do this:

```{.cpp .numberLines}
int numbers[60];

for(int i=0; i<60; i++)
	numbers[i] = i;

```

Notice that `numbers` will now contain $\{0,1,2,3, ..., 59\}$ as its elements. This seems to be redundant, because looking carefully at them, they are the indices of `numbers`.

Instead of storing the numbers in an array, we will instead use that index of the array.

```{.cpp .numberLines}
const int n = 60;
bool primes[n] = {[0 ... n-1]=true};
```

The above c++ snippet of code declares an array of boolean values called `primes`. And it initially sets all its elements to `true`. This is that part where we assume all the numbers are initially prime. 

```{.cpp .numberLines}
const int n = 60;
bool primes[n];
primes[0] = primes[1] = false; //0 and 1 are not prime.

for(int i=2; i<n; i++)
	primes[i] = true;

for(int i=2; i<n; i++){
	for(int j=i+i; j<n; j+=i)
		primes[j] = false;
}

for(int i=0; i<n; i++)
	if(primes[i]==true)
		cout<<i<<" ";

cout<<endl;
```

Let's compute for the $T(n)$ focusing on the actual sieve only.
```{.cpp .numberLines}
for(int i=2; i<n; i++){
	for(int j=i+i; j<n; j+=i)
		primes[j] = false;
}
```

The outer loop's lower and upper bounds are obvious. It is the inner loop that is interesting. 

The inner loop:
```{.cpp .numberLiens}
for(int j=i+i; j<n; j+=i)
	primes[j] = false;
```

$$
\begin{aligned}
inner\ loop &= \sum_{j=i+i}^{n-1}\overbrace{3}^{\texttt{j<n, primes[j]=false,j+=i}} + \underbrace{1}_{\texttt{j<n (false)}} + \overbrace{2}^{\texttt{j=i+i}}\\
&= \sum_{j=i+i}^{n-1}3 + 1 + 2\\
&= \sum_{j=i+i}^{n-1}3 + 3\\
\end{aligned}
$$

The above summation does not accurately compute the iterations in the inner loop. It fails to capture the `j+=i`.

When `i = 2`, notice that about half of the numbers get cancelled or its primality being reset to `false`. From here, it should be easy to see that about a third will be cancelled for when `i = 3`. A fourth in the next round, and so on. We keep doing this until we reach a point where we cancel just $1$ item that happens of be a multiple of a prime number. You can refer to the sample (all primes less than 60) we had in the early portion of this section to see the numbers that get cancelled. 

This gives us:

$$
\begin{aligned}
&\frac{n}{2}\ +\ \frac{n}{3}\ +\ \frac{n}{4} + \frac{n}{5}\ +\ ...\ +\ 1 \\
\\
n\cdot\Bigl(&\frac{1}{2}\ +\ \frac{1}{3}\ +\ \frac{1}{4} + \frac{1}{5}\ +\ ...\ +\ \frac{1}{n}\Bigr)
\end{aligned}
$$

$\frac{1}{2}\ +\ \frac{1}{3}\ +\ ...\ +\ \frac{1}{n}$ pretty much looks like the Harmonic series $\sum_{i=1}^{n}\frac{1}{i}$.

$$
\begin{aligned}
\sum_{i=1}^{n}\frac{1}{i} &= 1\ + \frac{1}{2}\ +\ \frac{1}{3}\ +\ \frac{1}{4} + \frac{1}{5}\ +\ ...\ +\ \frac{1}{n}\\
&\approx \ln(n)
\end{aligned}
$$

$\ln(n)$ here is the natural logarithm or natural log of $n$ which is $\approx \log_{2.71828}{n}$. It is important to note here that $\ln(n)$ grows slower than $\log_{2}{n}$.

The outer loop goes from 2 to n - 1, approximately we have:

$$
\begin{aligned}
\sum_{i=2}^{n-1}\frac{1}{i} &= \frac{1}{2}\ +\ \frac{1}{3}\ +\ \frac{1}{4} + \frac{1}{5}\ +\ ...\ +\ \frac{1}{n-1}\\
&\approx \ln(n) - 1 - \frac{1}{n}
&\
\end{aligned}
$$

Bringing back the $n$ that was factored out earlier, and adding in the $3$ statements that get executed many times over in the inner loop, we have:

$$
\begin{aligned}
\overbrace{3}^{\texttt{j<n, primes[j]=false,j+=i}}\cdot n\cdot\Bigl(\sum_{i=2}^{n-1}\frac{1}{i}\Bigl) &= 3\cdot n\cdot\Bigl(\frac{1}{2}\ +\ \frac{1}{3}\ +\ \frac{1}{4} + \frac{1}{5}\ +\ ...\ +\ \frac{1}{n-1}\Bigl)\\
&\approx 3n\cdot\Bigl(\ln(n) - 1 - \frac{1}{n}\Bigr) \\
&\approx 3n\ln(n) - 3n - 3\\
\end{aligned}
$$

Looking at the naive sieve again, some instructions have yet to be accounted for. There's the $2$ instructions, `j=i+i`, and when `j<n` evaluates to false. These instructions will be executed the same number of times as `i<n`, and `i++` of the outer loop. 

```{.cpp .numberLines}
for(int i=2; i<n; i++){
	for(int j=i+i; j<n; j+=i)
		primes[j] = false;
}
```
This gives us:

$$
\begin{aligned}
T(n) &\approx \sum_{i=2}^{n-1}\biggl(\overbrace{2}^{\texttt{i<n, i++}} + \overbrace{2}^{\texttt{j=i+i}} + \underbrace{1}_{\texttt{j<n (false)}}\biggl)\ + \underbrace{2}_{\texttt{i=2, i<n (false)}} + \overbrace{3n\ln(n) - 3n - 3}^{\texttt{j<n, primes[j]=false,j+=i}}\\
&\approx \sum_{i=2}^{n-1}5 + 2 + 3n\ln(n) - 3n - 3\\
&\approx 5\cdot(n-1 -2 + 1) + 3n\ln(n) - 3n - 3\\
&\approx 5\cdot(n-2) + 3n\ln(n) - 3n - 3\\
&\approx 5n - 10 + 3n\ln(n) - 3n - 3\\
&\approx 3n\ln(n) + 2n - 13\\
\end{aligned}
$$

Looking at our solution though, especially the inner loop, some items that have been cancelled already, are still cancelled. To address this, we only cancel the multiples of those that have not been cancelled. For instance, multiples of $4$ should no longer be cancelled since all its multiples have already been cancelled when the solution was cancelling multiples of $2$.

Shown next is the new version of the solution.

```{.cpp .numberLines}
for(int i=2; i<n; i++){
	if(primes[i]==true){
		for(int j=i+i; j<n; j+=i)
			primes[j] = false;
	}
}
```

This time around, we only cancel the multiples of primes. We now cancel all multiples $2$, then $3$, then $5$, $7$, $11$, $13$, ...

For the first iteration of the outer loop, we cancel about $\frac{n}{2}$ multiples, then $\frac{n}{3}$ multiples, etc. This is shown below:

$$
\begin{aligned}
&\frac{n}{2}\ +\ \frac{n}{3}\ +\ \frac{n}{5} + \frac{n}{7}\ +\ ...\ +\ 1 \\
\\
n\cdot\Bigl(&\frac{1}{2}\ +\ \frac{1}{3}\ +\ \frac{1}{5} + \frac{1}{7}\ +\ ...\ +\ \frac{1}{n}\Bigr)
\end{aligned}
$$

Euler, in the 18th century, was able to show that the sum of the reciprocals of prime numbers diverges.

$$
\begin{aligned}
\sum_{\text{primes p < n}}\frac{1}{p}&=\frac{1}{2}\ +\ \frac{1}{3}\ +\ \frac{1}{5} + \frac{1}{7}\ +\ \frac{1}{11}\ +\ ...\ \\
&\approx \ln\ln (n)\\
\end{aligned}
$$

Bringing back the $n$ that was factored out earlier, there are $3$ statements that that will have to be iterated many times over. 

Thus far, for all instances when  `primes[i]==true` checks out, we have:

$$
\begin{aligned}
\biggl(\overbrace{3}^{\texttt{j<n, primes[j]=false,j+=i}}\cdot n\cdot \Bigl(\sum_{\text{primes p < n}}\frac{1}{p}\Bigr) &=3n\cdot \biggl(\frac{1}{2}\ +\ \frac{1}{3}\ +\ \frac{1}{5} + \frac{1}{7}\ +\ \frac{1}{11}\ +\ ...\biggl)\\
&\approx 3n\ln\ln (n)\\
\end{aligned}
$$

We still need to account for the initialization of `j` and the lat check when `j<n` evaluates to false. Obviously, in the context of the inner loop, they get executed only once. We now have $3$ units of time to account for, i.e. `j = i+i` and `j<n`.

How many times will they be executed? Notice that they will executed only when `i` is prime, i.e. when `primes[i]==true` checks out. Effectively, we are asking given some $n$, how many prime numbers are there less $n$? 

The Prime Number Theorem is helpful here. The theorem states that the number of prime numbers less than or equal to a positive integer $n$, denoted by $\pi(n)$:

$$
\pi(n) \approx \frac{n}{\ln(n)}
$$

With this result, `j=i+i` and the last check on `j<n` will be executed approximately $\frac{n}{\ln(n)}$ times.

The full computation is shown below.

$$
\begin{aligned}
T(n) &\approx \sum_{i=2}^{n-1}\biggl(\overbrace{2}^{\texttt{i<n, i++}} + \overbrace{2}^{\texttt{j=i+i}} + \underbrace{1}_{\texttt{j<n (false)}}\biggl)\ + \overbrace{3n\ln\ln (n)}^{\texttt{j<n, primes[j]=false,j+=i}} + \underbrace{\frac{3n}{\ln(n)}}_{\texttt{j=i+i, j<n (false)}}\\
&\approx \sum_{i=2}^{n-1}5 + 2 + 3n\ln\ln (n) + \frac{3n}{\ln(n)}\\
&\approx 5\cdot(n-1 -2 + 1) + 3n\ln\ln (n)+ \frac{3n}{\ln(n)}\\
&\approx 5\cdot(n-2) + 3n\ln\ln (n)+ \frac{3n}{\ln(n)}\\
&\approx 5n - 10 + 3n\ln\ln (n)+ \frac{3n}{\ln(n)}\\
&\approx 3n\ln\ln (n)+ 5n + \frac{3n}{\ln(n)}- 10 \\
\end{aligned}
$$

We will no longer look into the version below, since the check on `primes[j]==true` will always be checked regardless as to how it evaluates, we did not really reduce the number of instructions to be executed.

```{.cpp .numberLines}
for(int i=2; i<n; i++){
	if(primes[i]==true){
		for(int j=i+i; j<n; j+=i){
			if(primes[j]==true) //has to be checked regardless
				primes[j] = false;
	}
}
```

## Cubic Time

### Matrix Multiplication

$$
	\begin{bmatrix} 
	a & b & c \\
	d & e & f \\
	g & h & i \\
	\end{bmatrix}
    \times
    \begin{bmatrix} 
	j & k & l \\
	m & n & o \\
	p & q & r \\
	\end{bmatrix}
$$

$$
    \begin{bmatrix} 
	aj+bm+cp & ak+bn+cq & al+bo+cr \\
	dj+em+fp & dk+en+fq & dl+eo+fr \\
	gj+hm+ip & gk+hn+iq & gl+ho+ir \\
	\end{bmatrix}
$$

Sample:

$$
	\begin{bmatrix} 
	1 & 2 & 3 \\
	2 & 3 & 4 \\
	6 & 5 & 4 \\
	\end{bmatrix}
    \times
    \begin{bmatrix} 
	0 & 2 & 1 \\
	6 & 3 & 0 \\
	4 & 7 & 5 \\
	\end{bmatrix}
    =
    \begin{bmatrix} 
	24 & 29 & 16 \\
	34 & 41 & 22 \\
	46 & 55 & 26 \\
	\end{bmatrix}
$$

Given two matrices $A$ and $B$, where A and B have dimensions $n \times n$ ($n$ rows and $n$ columns), the product matrix C is computed by taking the dot products of rows from matrix A and columns from matrix B. Based on the sample above, the element $C[i][j]$ is calculated as:

$$
C_{ij} = A_{i0}B_{0j} + A_{i1}B_{1j} + \ldots + A_{in}B_{nj}
$$

Note that the matrices do not necessarily have to be $n \times n$. We just have to make sure that the number of rows of the first matrix is equal to the number of columns of the second matrix.

```c
void matrixTimes(int A[N][N], int B[N][N], int C[N][N]){
	//for instance N defined as: #define N 1000 
    for(int i=0; i<N; i++){
        for(int j=0; j<N; j++){
            C[i][j] = 0;
            for(int k=0; k<N; k++){
                C[i][j] = C[i][j] + A[i][k]*B[k][j];
            }
        }
    }
}
```
Notice that we have $3$ nested loops. The strategy is still the same. We work our way from the innermost loop going outward. And we also adjust the bounds of the iterators to $1$ to $N$ from $0$ to $N-1$.

$$
\begin{aligned}
innermost\ for loop &= \sum_{k=1}^{N}\overbrace{5}^{\texttt{k<N, C[i][j] = C[i][j] + A[i][k] + B[k][j], k++}} + \underbrace{2}_{\texttt{k=0, k<N(false)}} \\
&= \sum_{k=1}^{N}5 + 2\\
&= 5N + 2\\
\end{aligned}
$$

This result is iterator N times together with the other statements of the second nested for loop.

Thus far, we have:

$$
\begin{aligned}
second\ inner\ for\ loop &= \sum_{j=1}^{N}\Bigl(\overbrace{3}^{\texttt{j<N, C[i][j]=0, j++}} + \underbrace{\sum_{k=1}^{N}5 + 2}_{{\texttt{innermost for loop}}} \Bigr) + \underbrace{2}_{\texttt{j=0, j<N(false)}} \\
&= \sum_{j=1}^{N}\Bigl(3 + \sum_{k=1}^{N}5 + 2\Bigr) + 2\\
&= \sum_{j=1}^{N}\Bigl(3 + 5N + 2\Bigr) + 2\\
&= \sum_{j=1}^{N}\Bigl(5N + 5\Bigr) + 2\\
&= \sum_{j=1}^{N}5N + \sum_{j=1}^{N}5 + 2\\
&= 5N^2 + 5N + 2
\end{aligned}
$$


The partial result abouve is iterated as many times as the other statements in the outermost for loop. Full computation is shown below.

$$
\begin{aligned}
T(n) &= \sum_{i=1}^{N}\biggl(\underbrace{2}_{\texttt{i<N, i++}}+\sum_{j=1}^{N}\Bigl(\overbrace{3}^{\texttt{j<N, C[i][j]=0, j++}} + \underbrace{\sum_{k=1}^{N}5 + 2}_{{\texttt{innermost for loop}}} \Bigr) + \underbrace{2}_{\texttt{j=0, j<N(false)}} \biggr) + \overbrace{2}^{\texttt{i=0 ,i<N(false)}}\\
&= \sum_{i=1}^{N}\biggl(2+\sum_{j=1}^{N}\Bigl(3 + \sum_{k=1}^{N}5 + 2 \Bigr) + 2 \biggr) + 2\\
&= \sum_{i=1}^{N}\biggl(2+\sum_{j=1}^{N}\Bigl(3 + 5N + 2 \Bigr) + 2 \biggr) + 2\\
&= \sum_{i=1}^{N}\biggl(2+\sum_{j=1}^{N}\Bigl(5N + 5 \Bigr) + 2 \biggr) + 2\\
&= \sum_{i=1}^{N}\biggl(2+5N^2 + 5N + 2 \biggr) + 2\\
&= \sum_{i=1}^{N}\biggl(5N^2 + 5N + 4\biggr) + 2\\
&= \sum_{i=1}^{N}5N^2 + \sum_{i=1}^{N}5N + \sum_{i=1}^{N}4 + 2\\
&= 5N^3 + 5N^2 + 4N + 2\\
\end{aligned}
$$

### Is n a power?

Given a postive integer $n \geq 2$, we determine it is a power of some base $b$.

One naive solution to this problem is to go from $i = 2$ and then compute for $b^k$, for each $k > 1$ as long as $b^k \leq n$. If we did not find such $k$, we proceed to the next $b$.

Let's check if $27$ is a power of some base $b$. We begin with $b=2$.

$$
\begin{aligned}
2^2 &\stackrel{?}{=} 27\\
2^3 &\stackrel{?}{=} 27\\
2^4 &\stackrel{?}{=} 27\\
2^5 &\stackrel{?}{=} 27\\
\end{aligned}
$$

Since $2^5$ is greater than $27$, we proceed to the next base, $b = 3$.

$$
\begin{aligned}
3^2 &\stackrel{?}{=} 27\\
3^3 &\stackrel{?}{=} 27\\
3^3 &\stackrel{\checkmark}{=} 27\\
\end{aligned}
$$

We can now conclude that $27$ is indeed a power of a base, $base = 3$.

The loop below generates the bases.

```{.cpp .numberLines}
for(int b=2; b<n ; b++)
	//do next step
	//for now let's n as the upper
```

The next step is to raise the base $b$ to some exponent. We generate the exponents, too.

```{.cpp .numberLines}
bool isPower(int n){
	for(int b=2; b<n ; b++){
		int pow = 1;
		for(int k=2; pow <= n; k++){
			pow = 1;
			for(int i=1; i<=k; i++)
				pow = pow * b;
			if(pow == n)
				return true;
		}
	}
	return false;
}
```

The solution above can still be improved based on the upper bound of the outermost loop. The worst-case scenario here is when $n$ is not a power of some base $b$. Let's take $n = 37$. Following our solution above, we have:

$$
\begin{aligned}
2^2 &\stackrel{?}{=} 37\\
2^3 &\stackrel{?}{=} 37\\
2^4 &\stackrel{?}{=} 37\\
2^5 &\stackrel{?}{=} 37\\
2^6 &\stackrel{?}{=} 37\\
\end{aligned}
$$

We move on to the next base, $b=3$ here since $2^6 > 37$.

$$
\begin{aligned}
3^2 &\stackrel{?}{=} 37\\
3^3 &\stackrel{?}{=} 37\\
3^4 &\stackrel{?}{=} 37\\
\end{aligned}
$$

We move on to the next base, $b=4$ here since $3^4 > 37$.

$$
\begin{aligned}
4^2 &\stackrel{?}{=} 37\\
4^3 &\stackrel{?}{=} 37\\
\end{aligned}
$$

We move on to the next base, $b=5$ here since $4^3 > 37$.

$$
\begin{aligned}
5^2 &\stackrel{?}{=} 37\\
5^3 &\stackrel{?}{=} 37\\
\end{aligned}
$$

We move on to the next base, $b=6$ here since $5^3 > 37$.

$$
\begin{aligned}
6^2 &\stackrel{?}{=} 37\\
6^3 &\stackrel{?}{=} 37\\
\end{aligned}
$$

We stop here since $6^3 > 37$. But do we proceed to the next base $b=7$? Actually, we can stop now since $7^2 > 37$. This means that the bases we generated should only go until $\sqrt{n}$. We rewrite our solution below.

```{.cpp .numberLines}
bool isPower(int n){
	for(int b=2; b*b<=n ; b++){
		int pow = 1;
		for(int k=2; pow <= n; k++){
			pow = 1;
			for(int i=1; i<=k; i++)
				pow = pow * b;
			if(pow == n)
				return true;
		}
	}
	return false;
}
```

We will use the new solution in computing for the $T(n)$. Again, we work from the innermost loop going outward.

$$
\begin{aligned}
innermost\ for\ loop\ &= \sum_{i=1}^{k}\overbrace{4}^{\texttt{i<=k, pow=pow*b, i++}} + \underbrace{2}_{\texttt{i=1, i<=k(false)}}\\
&= \sum_{i=1}^{k}4 + 2\\
&= 4k + 2\\
\end{aligned}
$$

The seond for loop is quite interesting. It should be easy to see that the bounds of the summation does not go from $2$ to $n$. What is being compared to $n$ is $pow$ and not $k$. We know $pow$. It is $b^k$. This should look familiar. We keep computing for the following:

$$
b^2,\ b^3,\ b^4,\ \ldots\ ,\ b^k\ \text{where we stop if } \ b^k \geq n.
$$

And we know when this stops, i.e. $k = \log_{b} n$. Shown below is the second nested for loop.
```{.cpp .numberLines}
for(int k=2; pow <= n; k++){
	pow = 1;
	for(int i=1; i<=k; i++)
		pow = pow * b;
	if(pow == n)
		return true;
}ÃŸ
```
$$
\begin{aligned}
\text{second nested for loop} &= \sum_{k=2}^{\log_{b}n}\Bigl(\underbrace{4}_{\texttt{pow<=n, pow=1, pow==n,k++}} +\overbrace{ \sum_{i=1}^{k}4 + 2}^{\texttt{innermost for loop}}\Bigr)+\underbrace{2}_{\texttt{k=2,pow<=n (false)}}\\
&= \sum_{k=2}^{\log_{b}n}\Bigl(4 +\sum_{i=1}^{k}4 + 2\Bigr)+2\\
&= \sum_{k=2}^{\log_{b}n}\Bigl(4 +4k + 2\Bigr)+2\\
&= \sum_{k=2}^{\log_{b}n}\Bigl(4k + 6\Bigr)+2\\
&= \sum_{k=2}^{\log_{b}n}4k + \sum_{k=2}^{\log_{b}n}6 + 2\\
&= 4\cdot\Bigl(\sum_{k=1}^{\log_{b}n}k - \sum_{k=1}^{1}k\Bigr)  + \sum_{k=2}^{\log_{b}n}6 + 2\\\\
&= 4\cdot\biggl(\frac{\log_bn(\log_bn + 1)}{2} - \frac{1(1 + 1)}{2}\biggr)  + 6\cdot(\log_bn -2 + 1) + 2\\\\
&= 4\cdot\biggl(\frac{\log_bn(\log_bn + 1)}{2} - \frac{2}{2}\biggr)  + 6\cdot(\log_bn - 1) + 2\\\\
&= 4\cdot\biggl(\frac{\log_bn(\log_bn + 1)}{2} - 1\biggr)  + 6\log_bn - 6 + 2\\\\
&= 4\cdot\biggl(\frac{\log_b^2n+\log_bn}{2} - 1\biggr)  + 6\log_bn - 4\\\\
&= 2\log_b^2n+2\log_bn - 4  + 6\log_bn - 4\\\\
&= 2\log_b^2n+8\log_bn - 8\\
\end{aligned}
$$

Finally, incorporating the outermost loop, we have:

```{.cpp .numberLines}
for(int b=2; b*b<=n ; b++){
	int pow = 1;
	for(int k=2; pow <= n; k++){
		pow = 1;
		for(int i=1; i<=k; i++)
			pow = pow * b;
		if(pow == n)
			return true;
	}
}
return false;
```

$$
\begin{aligned}
T(n) &= \sum_{b=2}^{\sqrt{n}}\Bigl(\overbrace{4}^{\texttt{b*b<=n, pow=1, b++}} + \overbrace{2\log_b^2n+8\log_bn - 8}^{\texttt{inner 2 nested loops}}\Bigr)+\overbrace{3}^{\texttt{b=2, b*b<=n(false)}}\\
&= \sum_{b=2}^{\sqrt{n}}\Bigl(4 + 2\log_b^2n+8\log_bn - 8\Bigr)+3\\
&= \sum_{b=2}^{\sqrt{n}}\Bigl(2\log_b^2n+8\log_bn - 4\Bigr)+3\\
&= \sum_{b=2}^{\sqrt{n}}2\log_b^2n+\sum_{b=2}^{\sqrt{n}}8\log_bn - \sum_{b=2}^{\sqrt{n}}4 + 3\\
\end{aligned}
$$

Unfortunately, $\sum_{b=1}^{n}\log_bn$ does not have a closed-form sum. What we can is to just approximate T(n). We can use base $2$ instead of the variable $b$, i.e. $\sum_{b=1}^{n}\log_2n$.

This would make $\log_2n$ constant. Among all the bases we have (from $2$ to $\sqrt{n}$), $\log_2n$ grows that fastest, hence the choice. Continuing from this simplification, we now have:

$$
\begin{aligned}
T(n) &\leq \sum_{b=2}^{\sqrt{n}}2\log_2^2n+\sum_{b=2}^{\sqrt{n}}8\log_2n - \sum_{b=2}^{\sqrt{n}}4 + 3\\
&\leq 2\log_2^2n(\sqrt{n}-2+1)+8\log_2n(\sqrt{n}-2+1) - 4(\sqrt{n}-2+1) + 3\\
&\leq 2\log_2^2n(\sqrt{n}-1)+8\log_2n(\sqrt{n}-1) - 4(\sqrt{n}-1) + 3\\
&\leq 2\sqrt{n}\log_2^2n-2\log_2^2n+8\sqrt{n}\log_2n-8\log_2n - 4\sqrt{n}-4 + 3\\
&\leq 2\sqrt{n}\log_2^2n-2\log_2^2n+8\sqrt{n}\log_2n-8\log_2n - 4\sqrt{n}-1\\
\end{aligned}
$$

What we are saying here is that the computed $T(n)$ above is the upper bound. And obviously, the $T(n)$ is definitely less than the computed function.

## Better isPower solution

If we revisit our naive solution, we can improve on this. Let's look at $27$ again. If it is a power, there must be some base $b$ that can evenly divide $27$ repeatingly until it gets reduced to 1. This is shown below.

$$
\begin{aligned}
27\div 3 &= 9\\
9\div 3 &= 3\\
3\div 3 &= 1\\
\end{aligned}
$$

Let's take $18$ which is not a power.

$$
\begin{aligned}
18\div 3 &= 6\\
6\div 3 &= 2\\
\end{aligned}
$$

Notice that the last quotient $2$ is no longer divisible by 3. And so we stop. We only divide it when it is divisibel by the candidate base, until we reach a quotient of 1.

In the case of $18$, we continue looking for another base until its square root, similar to what we had in the naive solution.

It should be clear by now that our new solution will no longer have $3$ nested loops.

The following shows the improved solution.

```{.cpp .numberLines}
bool realPower(int n){
	for(int b=2; b*b<=n; b++){
		if(n%b==0){
			int tmp = n;
			while(tmp>1){
				if(tmp%b==0)
					tmp = tmp / b;
				else
					break;
			}
			if(tmp==1)
				return true;
		}
	}
	return false;
}
```

Again, we begin with the inner loop, the while loop. $tmp$ starts at $n$, and it is repeatingly divided by the base. So we have:

$$
n,\ \frac{n}{b},\ \frac{n}{b^2},\ \ldots\ ,\ \frac{n}{b^k}\ \text{where we stop if } \ b^k = n. 
$$

This means $tmp$ is $1$ when $b^k = n$. We exclude this in the iteration since the condition in the while loop is `tmp>1`.

Again, we already know what $k$ is, $k = \log_bn$.


$$
\begin{aligned}
\\
\text{inner for loop} &= \sum_{i=1}^{\log_bn}\overbrace{5}^{\texttt{tmp>1, tmp\%b==0, tmp=tmp/b}} + \overbrace{1}^{\texttt{tmp>1(false)}}\\
&= \sum_{i=1}^{\log_bn}5 + 1\\
&= 5\log_bn + 1\\
\end{aligned}
$$

Let's complete by incorporating the outer loop.

$$
\begin{aligned}
\\
T(n) &= \sum_{b=2}^{\sqrt{n}}\overbrace{7}^{\texttt{b*b<=n, n\%b==0, tmp=n, tmp==1, b++}} +  \underbrace{5\log_bn + 1}_{\text{inner loop}}\Bigr)+\overbrace{4}^{\texttt{b=2, b*b<=(false), return false}}\\\\
&= \sum_{b=2}^{\sqrt{n}}\Bigl(7 + 5\log_bn + 1\Bigr)+4\\
&= \sum_{b=2}^{\sqrt{n}}\Bigl(5\log_bn + 8\Bigr)+4\\
&= \sum_{b=2}^{\sqrt{n}}5\log_bn + \sum_{b=2}^{\sqrt{n}}8 + 4\\
\end{aligned}
$$

We, again, encounter a sum similar to $\sum_{b=1}^{\sqrt{n}}\log_bn$ which we now know does not have a closed-form. We do what we did earlier and simplify the sum using a constant base, $b = 2$ since from among all the bases, $2$ grows the fastest.

Continuing, we have:

$$
\begin{aligned}
\\
T(n) &\leq \sum_{b=2}^{\sqrt{n}}5\log_2n + \sum_{b=2}^{\sqrt{n}}8 + 4\\
&\leq 5\log_2n \cdot(\sqrt{n} - 2 + 1) + 8 \cdot(\sqrt{n} - 2 + 1) + 4\\
&\leq 5\log_2n \cdot(\sqrt{n} - 1) + 8 \cdot(\sqrt{n} - 1) + 4\\
&\leq 5\sqrt{n}\log_2n - 5\log_2n + 8 \sqrt{n} - 8 + 4\\
&\leq 5\sqrt{n}\log_2n - 5\log_2n + 8 \sqrt{n} - 4\\
\end{aligned}
$$

Again, we say that what we have computed is an upper bound, hence, $T(n) \leq 5\sqrt{n}\log_2n - 5\log_2n + 8 \sqrt{n} - 4$.

Observe that when we computed for the $T(n)$, we simply assumed that for every iteration of the while loop, it does not break. We have also assumed that the check `n%b==0` is always `true` and that the check `tmp==1` is always false. Only to return `false` at the end.

If the function returns false, this would mean that it isn't a power. If it isn't a power, it is impossible for the inner while loop to not break. Also, it is impossible for `n%b==0` to always evaluate to `true` for every iteration.

Hence, we beg the question, what is the worst-case scenario for the new isPower solution?
